<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>Concrete Clicker</title>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<link rel="stylesheet" type="text/css" href="game.css">
</head>

<body>

    
<script>

// SETUPGAME
var gm = new Game();
var active_tab = '';
var tmr = null;
var sec_tmr = null;
var save_tmr = null;
var last_save_tmr = null;
var stat_tmr = null;
var event_tmr = null;
var ver_tmr = null;
var last_tick = (new Date).getTime();
var last_saved = 0;
var last_click = 0;
var last_bust = 0;
var last_float = 10;
var tick_ms = 100;

$(document).ready(function() {
    gm.setup_display();
    tmr = setInterval("gm.tick()", tick_ms);
    sec_tmr = setInterval("gm.sec_tick()", 1000);
    save_tmr = setInterval("gm.do_save()", 30000);
    event_tmr = setInterval("gm.check_events()", 120000);
    ver_tmr = setInterval("gm.check_version()", 620000);
    gm.do_load();
    var bind_type = 'click';
    bind_type = 'touchstart click';}
    
    $('#make_btn').bind(bind_type, function(e) 
    { 
    gm.do_make_click();
            var this_float = e.pageX - 60;
            last_float = 1; 
    }

    $('#sell_btn').bind(bind_type, function(e) 
    { 
        var sale = gm.do_sell_click();
        if(sale == 0) { 
            return;
        }
            var this_float = e.pageX - 60;
            last_float = 1; 
    }
   
    switch_tab('clickers');
    $('button').attr('disabled', false);



function Game() { 

    var pd = {
        'title':'Concrete Clicker',
        'make_amount':1,
        'make_rps_multiplier':0,
        'sell_amount':1,
        'sell_rps_multiplier':0,
        'sell_return':0.5,
        'economy_roi':1,
        'difficulty_level':0,
        'cash': {
            'amount':0,
            'safe':0, 
            'safe_rps':0,
            'label':'Cash Money',
            'action_label':'SELL!',
        },
        'widget_roi':0.5,
        'widgets':{
            'amount':0,
            'label':'Batches',
            'action_label':'COOK!',
            'qualities':{
                1: 'Deadly',
                2: 'Dangerous',
                4: 'Unhealthy',
                6: 'Cloudy',
                10: 'Poor',
                13: 'Average',
                16: 'Good',
                20: 'Crystal',
                25: 'Blue Gold',
                50: 'Blue Platinum',
                100: 'FDA Approved Additive',
                159: 'Atomically Perfect',
                211: 'Holy',
                300: 'Angelic',
                1000: 'Nectar of The Gods',
            },
        },
        
        // MANUFACTURING
        'clickers':{
            '01_storage_shed':{
                'label':'Storage Shed',
                'description':'A cheap shed with electricity',
                'amount':0,
                'risk':0.05,
                'rps':.2,
                'base_cost':20,
                'cost':20,
                'unlock_rps':0,
                'unlocked':true,
                'sid':'c1',
            },
            '03_used_rv':{
                'label':'Used RV',
                'description':'A low cost RV, perfect for remote cooking',
                'amount':0,
                'risk':0.005,
                'rps':1,
                'base_cost':210,
                'cost':210,
                'unlock_rps':.2,
                'unlocked':false,
                'sid':'c2',
            },
        },
        // END clickers


        // DISTRIBUTION
        'sellers':{
            '01_dealer':{
                'label':'Dealer',
                'description':'A common street thug to sell your goods',
                'amount':0,
                'risk':0.03,
                'rps':.2,
                'base_cost':20,
                'cost':20,
                'unlock_rps':0.5,
                'unlocked':true,
                'sid':'s1',
            },
            '03_drug_mule':{
                'label':'Drug Mule',
                'description':'Someone to stuff drugs in their rectum and distribute them',
                'amount':0,
                'risk':0.005,
                'rps':1,
                'base_cost':230,
                'cost':230,
                'unlock_rps':.2,
                'unlocked':false,
                'sid':'s2',
            },
        }, 
        // END sellers


        // UPGRADES
        'upgrades':{
            // UPG VENTILATION STUFF
            '00_air_fresheners':{
                'label':'Air Fresheners',
                'description':'With the sweet sent of pine in the air, you can cook an extra batch at a time.',
                'action':'make_amount',
                'purchased':false,
                'mod':1,
                'cost':10,
                'prereq':null,
                'sid':'u01',
            },
            '01_exhaust_fan':{
                'label':'Exhaust Fan',
                'description':'You can now cook 5 more batches at a time',
                'action':'make_amount',
                'purchased':false,
                'mod':5,
                'cost':100,
                'prereq':'00_air_fresheners',
                'sid':'u02',
            },
        }, 
            
    // sec_tick() - Runs every 1000ms 
    this.sec_tick = function() {
        fix_saved();
        fix_stats();
        check_achievements();
    }

    // tick() - Runs every tick_ms (default 100ms)
    this.tick = function() { 
        var this_tick = (new Date).getTime();
        var this_sub = 1000 / tick_ms;
        var ticks = Math.round((this_tick - last_tick) / tick_ms);
        if(ticks > 360000) { 
            ticks = 360000;
        } else if (ticks < 1) { 
            return;
        }
        last_tick = this_tick;

        // Negative fix
        if(pd.cash.amount < 0) { 
            this.error_log('negative_cash: '+pd.cash.amount);
            pd.cash.amount = 0;
        } 
        if(pd.widgets.amount < 0) { 
            this.error_log('negative_widgets: '+pd.widgets.amount);
            pd.widgets.amount = 0;
        }
        if(pd.cash.safe < 0) {
            this.error_log('negative_safe_cash: '+pd.cash.safe);
            pd.cash.safe = 0;
        }

        // Make widgets (meth)
        var make_amount = 0;
        for(var k in pd.clickers) {
            var cl = pd.clickers[k]; 
            make_amount += cl.amount * cl.rps;
        }
        pd.stats.clicker_rps = make_amount;
        make_amount = make_amount / this_sub;
        do_make(make_amount * ticks);
      
        // Sell widgets
        var sell_amount = 0;
        for(var k in pd.sellers) { 
            var sl = pd.sellers[k];
            sell_amount += sl.amount * sl.rps;
        }
        pd.stats.seller_rps = sell_amount;
        sell_amount = sell_amount / this_sub;

        do_sell(sell_amount * ticks);

    // Earn cash
    function earn_cash(n) { 
        pd.cash.amount += n;
        return true;
    }

    // Spend cash
    function spend_cash(n) {
        if(n > (pd.cash.amount)) {
            return false;
        } 
        pd.cash.amount -= n;
        pd.stats.total_spent += n;
        return true;
    }

    this.get_click_sell_amount = function() { 
        return pd.sell_amount + (pd.stats.seller_rps * pd.sell_rps_multiplier);
    }

    this.get_click_make_amount = function() { 
        return pd.make_amount + (pd.stats.clicker_rps * pd.make_rps_multiplier);
    }

    this.get_widget_roi = function() {
        return pd.widget_roi;
    }

    this.get_title = function() { 
        return pd.title;
    }
    this.dump_pd = function(key) { 
        console.log(pd[key]);
    }
    function get_item_cost(scl) { 
        var cst = ((scl.amount + 1) * scl.base_cost) * (scl.amount + 1);
        // Double costs if > 10 are owned
        if((scl.amount + 1) > 10) { 
            cst *= 2;
        }
        return cst;
    }

    function get_item_last_cost(scl) { 
        var cst = ((scl.amount) * scl.base_cost) * (scl.amount);
        // Double costs if > 10 are owned
        if(scl.amount > 10) { 
            cst *= 2;
        }
        return cst;
    }

    function get_item_sell_value(scl) {
        return get_item_last_cost(scl) * (pd.sell_return * pd.economy_roi);
    }
    
    function get_safe_cash() { 
        if(pd.cash.safe > pd.cash.amount) {
            return pd.cash.amount;
        } else { 
            return pd.cash.safe;
        }
    }

    function get_unsafe_cash() { 
        var unsafe = pd.cash.amount - pd.cash.safe;
        if(unsafe < 0) { unsafe = 0; }
        return unsafe;
    }

    function get_hex_from_int(n) { 
        return n.toString(24);
    }
    function get_int_from_hex(s) { 
        return parseInt(s, 24);
    }
 
        // Clickers 
        for(var k in pd.clickers) { 
            sv.clickers[k] = {
                'amount':pd.clickers[k].amount,
                'unlocked':pd.clickers[k].unlocked,
            };
        }
        // Sellers
        for(var k in pd.sellers) { 
            sv.sellers[k] = {
                'amount':pd.sellers[k].amount,
                'unlocked':pd.sellers[k].unlocked,
            };
        }
        // Upgrades 
        for(var k in pd.upgrades) { 
            sv.upgrades[k] = {
                'purchased':pd.upgrades[k].purchased,
            };
        }
        return sv;
    }
    function new_pd_to_json() { 
        var sdata = {
            'c':get_hex_from_int(Math.round(pd.cash.amount)),
            'cs':get_hex_from_int(Math.round(pd.cash.safe)),
            'w':get_hex_from_int(Math.round(pd.widgets.amount)),
        };
       
        var unlockables = {
            "clickers":"cl",
            "sellers":"sl",
        };
        for(var k in unlockables) { 
            var items = pd[k];
            var sk = unlockables[k];
            var tmpa = [];
            for(var ik in items) { 
                if(items[ik].unlocked) {
                    tmpa.push(
                        items[ik].sid
                        + ":" +
                        get_hex_from_int(items[ik].amount)
                    ); 
                }
            }
            sdata[sk] = tmpa.join('|');
        }
        // Upgrades
        var tmpu = [];
        for(var k in pd.upgrades) { 
            var u = pd.upgrades[k];
            if(u.purchased) { 
                tmpu.push(u.sid); 
            }
        }
        sdata['u'] = tmpu.join('|')

        // Stats
        var tmps = [];
        for(var k in pd.stats) { 
            tmps.push(k+':'
                +get_hex_from_int(pd.stats[k])
            );
        }
        sdata['s'] = tmps.join('|');
        return sdata;
    }

    /****************************************************************************** 
     * ACTIONS
     */
    function do_make(n) {
        pd.widgets.amount += n;   
        pd.stats.made_widgets += n; 
        return true;
    }

    this.do_make_click = function() { 
        last_click = nw;
        var amt = this.get_click_make_amount();
        if(do_make(amt)) { 
            //message('You made '+pretty_int(pd.make_amount)+' '+pd.widgets.label);
            pd.stats.hand_made_widgets += amt;
            fix_make_sell();
        }
    }

    function do_sell(n) { 
        if(pd.widgets.amount < 1) {
            return 0;
        }         
        if(n > pd.widgets.amount) {
            n += (pd.widgets.amount - n);
            if(n < 1) { 
                return 0;
            } 
        }
        pd.stats.sold_widgets += n;
        pd.widgets.amount -= n;
        earn_cash(n * pd.widget_roi);
        pd.stats.total_cash += (n * pd.widget_roi);
        return n;
    }

    this.do_sell_click = function() {
        last_click = nw;
        var sale = do_sell(this.get_click_sell_amount());
        if(sale) { 
            //message('You sold '+pretty_int(sale)+' '+pd.widgets.label);
            pd.stats.hand_sold_widgets += sale;
            fix_make_sell();
            return sale;
        }
        return 0;
    }

    function get_widget_quality() { 
        var keys = Object.keys(pd.widgets.qualities).sort(function(a,b){return a-b});
        for(var i=0; i<keys.length; i++) { 
            var idx = keys[i];
            if(pd.widget_roi > idx) { 
                continue;
            }
            return pd.widgets.qualities[idx];
        }
        return 'NA';
    }


    /****************************************************************************** 
     * BUY/SELL STUFF
     */

    this.buy_bank = function(key) {
        var bn = pd.banks[key];
        if(!bn) { 
            return error('Invalid bank key');
        }
        if(!spend_cash(bn.cost)) { 
            return false;
        }
        bn.amount += 1;
        message('You have purchased a '+bn.label+' for $'+pretty_bigint(bn.cost));
        //track_page_view('/game_buy_bank');
        return true;
    }

    this.sell_bank = function(key) { 
        var bn = pd.banks[key];
        if(bn.amount < 1) { 
            return false;
        }
        var sell_val = get_item_sell_value(bn);
        earn_cash(sell_val);
        message('You sold a '+bn.label+' for $'+pretty_bigint(sell_val));
        //track_page_view('/game_sell_bank');
        bn.amount -= 1;
        return true;
    }

    this.buy_clicker = function(key) { 
        var cl = pd.clickers[key];
        if(!spend_cash(cl.cost)) { 
            return false;
        }
        cl.amount += 1;
        message('You have purchased a '+cl.label+' for $'+pretty_bigint(cl.cost));
        fix_clickers();
        //track_page_view('/game_buy_clicker');
        return true;
    }

    this.sell_clicker = function(key) { 
        var cl = pd.clickers[key];
        if(cl.amount < 1) { 
            return false;
        }
        var sell_val = get_item_sell_value(cl);
        earn_cash(sell_val);
        message('You sold a '+cl.label+' for $'+pretty_bigint(sell_val));
        //track_page_view('/game_sell_clicker');
        cl.amount -= 1;
        return true;
    }

    this.buy_seller = function(key) { 
        var sl = pd.sellers[key];
        if(!spend_cash(sl.cost)) { 
            return false;
        }
        sl.amount += 1;
        message('You have purchased a '+sl.label+' for $'+pretty_bigint(sl.cost));
        fix_sellers();
        //track_page_view('/game_buy_seller');
        return true;
    }

    this.sell_seller = function(key) { 
        var sl = pd.sellers[key];
        if(sl.amount < 1) { 
            return false;
        }
        var sell_val = get_item_sell_value(sl);
        earn_cash(sell_val);
        message('You sold a '+sl.label+' for $'+pretty_bigint(sell_val));
        //track_page_view('/game_sell_seller');
        sl.amount -= 1;
        return true;
    }

    this.buy_upgrade = function(key) { 
        var upg = pd.upgrades[key];
        var unl = apply_upgrade(key);
        if(!unl) { 
            return false;
        }
        if(!spend_cash(upg.cost)) {
            return false; 
        } 
        message('You have unlocked '+upg.label+' for $'+pretty_bigint(upg.cost));
        track_page_view('/game_buy_upgrade');
        fix_upgrades();
    }

    function apply_upgrade(key) { 
        var upg = pd.upgrades[key];
        if(!upg) { 
            return false; 
        }
        if(upg.purchased) { 
            return false;
        }
        upg.purchased = true;
        var act_parts = upg.action.split('.');
        if(act_parts.length == 1) { 
            pd[act_parts[0]] += upg.mod;
        } else if(act_parts.length == 2) {
            pd[act_parts[0]][act_parts[1]] += upg.mod;
        } else if(act_parts.length == 3) { 
            pd[act_parts[0]][act_parts[1]][act_parts[2]] += upg.mod;
        }

        return true;
    }

    function unlock_achievement(key) { 
        var ac = pd.achievements[key];
        if(!ac) { 
            return false;
        }
        if(ac.unlocked) { 
            return false; 
        }
        ac.unlocked = true;
        good_message('You have earned a new achievement: <em>'+ac.label+'</em>');
        return true;
    }

    /****************************************************************************** 
     * FIX DISPLAY 
     */

    function fix_display() { 
        fix_unlocks();
        fix_clickers();
        fix_sellers();
        fix_upgrades();
        fix_make_sell();
        fix_title();
        fix_risk();
        fix_achievements();
        fix_banks(); 
    }

    function fix_achievements() {
        if(active_tab != 'achievements') { 
            return false;
        }
        for(var k in pd.achievements) { 
            var ac = pd.achievements[k];
            var el = $('#'+k);
            var el_lbl = $('#'+k+'_lbl');
            if((ac.hidden)&&(!ac.unlocked)) {
                el.addClass('hidden'); 
                continue;
            }
            if(ac.unlocked) { 
                el.removeClass('hidden');
                el.removeClass('semi_trans');
                el_lbl.addClass('purchased');
                el.removeClass('locked');
            } else { 
                el.addClass('locked');
                el.addClass('semi_trans');
            }
        }

    }

    function fix_banks() {
        if(active_tab != 'banks') { 
            return; 
        }

        $('#bank_rps').html(pretty_bigint(pd.stats.bank_rps));
        $('#bank_total').html(pretty_bigint(pd.cash.safe));
        for(var k in pd.banks) {
            var bn = pd.banks[k];
            bn.cost = get_item_cost(bn);
            var el = $('#'+k);
            var el_btn = $('#'+k+'_btn');
            var el_sell_btn = $('#'+k+'_sell_btn');
            var el_lbl = $('#'+k+'_lbl');
            var el_cst = $('#'+k+'_cst');
            var el_amt = $('#'+k+'_amt');
            var el_rps = $('#'+k+'_rps');
        
            el_amt.html(pretty_int(bn.amount));
            el_cst.html(pretty_bigint(bn.cost));
            el_rps.html(pretty_bigint(bn.rps));

            if((!bn.unlocked)) { 
                el.addClass('hidden');
                continue;
            }
            
            if(pd.cash.amount < bn.cost) {
                el_btn.attr('disabled',true);
            } else { 
                el_btn.attr('disabled',false);
            }

            if(bn.amount < 1) {
                el_sell_btn.attr('disabled',true);
            } else { 
                el_sell_btn.attr('disabled',false);
            }
                
            el.removeClass('hidden');
        }
    }

    function fix_risk() { 
        pd.risk_amount = get_risk();
        pd.risk2_amount = get_risk2();
        $('#risk_amount').html(pretty_int(pd.risk_amount * 100)); 
        $('#risk2_amount').html(pretty_int(pd.risk2_amount * 100));
        var el_lvl = $('#risk_level');
        var el_lvl2 = $('#risk2_level');
        var slvl = false;
        var slvl2 = false;
        for(var i=0; i<pd.risk_levels.length; i++) {
            if((pd.risk_amount < pd.risk_levels[i].level) && (!slvl)) {
                el_lvl.html(pd.risk_levels[i].label);
                slvl = true;
            }
            if((pd.risk2_amount < pd.risk_levels[i].level) && (!slvl2)) { 
                el_lvl2.html(pd.risk_levels[i].label);
                slvl2 = true;
            }
        }
        
    }

    function fix_saved() { 
        last_saved += 1;
        $('#last_saved').html('Game saved '+last_saved+' seconds ago');
    }

    function fix_title() { 
        document.title = '$'+pretty_bigint(pd.cash.amount)+' | '+pd.title;
    }

    function fix_make_sell() { 
        $('#sell_btn').html(pd.cash.action_label);
        $('#sell_lbl').html(pd.cash.label);
        $('#sell_amt').html(pretty_int(pd.cash.amount));
        $('#sell_roi').html(pd.widget_roi.toFixed(2));
        $('#safe_cash').html(pretty_int(get_safe_cash()));
        var sell_rate = pd.stats.seller_rps;
        if((pd.stats.seller_rps > pd.stats.clicker_rps)&&(pd.widgets.amount < pd.stats.seller_rps)) { 
            sell_rate = pd.stats.clicker_rps;
        }
        $('#seller_rps').html(pretty_int(sell_rate * pd.widget_roi));
        $('#make_btn').html(pd.widgets.action_label);
        $('#make_lbl').html(pd.widgets.label);
        $('#make_amt').html(pretty_int(pd.widgets.amount));
        $('#make_qlt').html(get_widget_quality());
        $('#clicker_rps').html(pretty_int(pd.stats.clicker_rps-pd.stats.seller_rps));
        $('#clicker_rps_g').html(pretty_int(pd.stats.clicker_rps));
    }

    function fix_clickers() {
        if(active_tab != 'clickers') {
            return false;
        } 
        for(var k in pd.clickers) { 
            var el = $('#'+k);
            var el_btn = $('#'+k+'_btn');
            var el_sell_btn = $('#'+k+'_sell_btn');
            var el_amt = $('#'+k+'_amt');
            var el_cst = $('#'+k+'_cst');
            var el_rps = $('#'+k+'_rps');
            var el_rsk = $('#'+k+'_rsk');

            var cl = pd.clickers[k];
            if(cl.amount > 0) { 
                el_sell_btn.attr('disabled', false);
            } else { 
                el_sell_btn.attr('disabled', true);
            }
            
            cl.cost = get_item_cost(cl); 
            
            if(cl.cost > pd.cash.amount) { 
                el_btn.attr('disabled', true);
            } else { 
                el_btn.attr('disabled', false);
            }
            if(!cl.unlocked) { 
                el.addClass('hidden');
            } else { 
                el.removeClass('hidden');
            }
            el_cst.html(pretty_bigint(cl.cost));
            el_amt.html(pretty_int(cl.amount));
            el_rps.html(pretty_bigint(cl.rps));
            el_rsk.html(pretty_int(cl.risk * 100));
        }
    }

    function fix_sellers() {
        if(active_tab != 'sellers') { 
            return;
        } 
        for(var k in pd.sellers) { 
            var el = $('#'+k);
            var el_btn = $('#'+k+'_btn');
            var el_sell_btn = $('#'+k+'_sell_btn');
            var el_amt = $('#'+k+'_amt');
            var el_cst = $('#'+k+'_cst');
            var el_rps = $('#'+k+'_rps');
            var el_rsk = $('#'+k+'_rsk');

            var sl = pd.sellers[k];

            if(sl.amount < 1) { 
                el_sell_btn.attr('disabled', true);
            } else { 
                el_sell_btn.attr('disabled', false);
            }

            sl.cost = get_item_cost(sl);

            if(sl.cost > pd.cash.amount) {
                el_btn.attr('disabled', true); 
            } else { 
                el_btn.attr('disabled', false);
            }
            if(!sl.unlocked) { 
                el.addClass('hidden');
            } else { 
                el.removeClass('hidden');
            }
            el_cst.html(pretty_bigint(sl.cost));
            el_amt.html(pretty_int(sl.amount));
            el_rps.html(pretty_bigint(sl.rps));
            el_rsk.html(pretty_int(sl.risk * 100));
        }
    }

    function fix_unlocks() {
        // Clickers
        var cl_unl = 0;
        var cl_tot = 0; 
        for(var k in pd.clickers) { 
            cl_tot += 1;
            var cl = pd.clickers[k];
            if(cl.unlock_rps <= pd.stats.seller_rps) { 
                cl.unlocked = true;
                cl_unl += 1;
            }
        }
        $('#clickers_unlocked').html(pretty_int(cl_unl));
        $('#clickers_total').html(pretty_int(cl_tot));

        // Sellers
        var sl_unl = 0;
        var sl_tot = 0;
        for(var k in pd.sellers) { 
            sl_tot += 1;
            var sl = pd.sellers[k];
            if(sl.unlock_rps <= pd.stats.seller_rps) {
                sl_unl += 1;
                sl.unlocked = true;        
            }
        }
        $('#sellers_unlocked').html(pretty_int(cl_unl));
        $('#sellers_total').html(pretty_int(cl_tot));

        // Banks
        var bn_unl = 0;
        var bn_tot = 0;
        for(var k in pd.banks) { 
            bn_tot += 1;
            var bn = pd.banks[k];
            if((bn.unlock_rps <= pd.stats.seller_rps)||(bn.unlocked)) { 
                bn_unl += 1;
                bn.unlocked = true;
            }
        }
        $('#banks_total').html(pretty_int(bn_tot));
        $('#banks_unlocked').html(pretty_int(bn_unl));

        // Achievements
        var ac_unl = 0;
        var ac_tot = 0;
        for(var k in pd.achievements) { 
            var ac = pd.achievements[k];
            if((!ac.unlocked)&&(ac.hidden)) { 
                continue;
            }
            if(ac.unlocked) { 
                ac_unl += 1;
            }
            ac_tot += 1;
        }
        $('#achievements_unlocked').html(pretty_int(ac_unl));
        $('#achievements_total').html(pretty_int(ac_tot));

    }

    function fix_upgrades() {
        var up_tot = 0;
        var up_unl = 0; 
        for(var k in pd.upgrades) {
            var el = $('#'+k); 
            var el_btn = $('#'+k+'_btn');
            var el_cst = $('#'+k+'_cst');
            var upg = pd.upgrades[k];

            if((upg.prereq)) { 
                var req = pd.upgrades[upg.prereq];
                if((req)&&(!req.purchased)) {
                    up_tot += 1;
                    el.addClass('hidden');
                    continue;
                } 
            } 

            if((upg.prereq == 'hidden')&&(!upg.purchased)) { 
                el.addClass('hidden');
                continue;
            } else { 
                up_tot += 1;  
            }  
            
            if(upg.purchased) { 
                el_btn.addClass('hidden');
                $('#'+k+'_lbl').addClass('purchased');
                el_cst.html('&#10004;');
                up_unl += 1;
            } else { 
                el_cst.html('$'+pretty_bigint(upg.cost));
            }
            if(pd.cash.amount < upg.cost) { 
                el_btn.attr('disabled', true);
            } else { 
                el_btn.attr('disabled', false);
            }
            el.removeClass('hidden');
        }
        $('#upgrades_unlocked').html(pretty_int(up_unl));
        $('#upgrades_total').html(pretty_int(up_tot));
    }


    function fix_stats() {
        pd.stats.seconds_played += 1;
        pd.stats.bought_upgrades = 0;
        for(var k in pd.upgrades) { 
            if(pd.upgrades[k].purchased) { 
                pd.stats.bought_upgrades += 1;
            }
        }
        
        if(active_tab != 'misc') { return; }
        $('#hand_made_widgets').html(pretty_bigint(pd.stats.hand_made_widgets));
        $('#made_widgets').html(pretty_bigint(pd.stats.made_widgets));
        $('#sold_widgets').html(pretty_bigint(pd.stats.sold_widgets));
        $('#hand_sold_widgets').html(pretty_bigint(pd.stats.hand_sold_widgets));
        $('#total_cash').html(pretty_bigint(pd.stats.total_cash));
        $('#total_spent').html(pretty_bigint(pd.stats.total_spent));
        $('#bought_upgrades').html(pretty_int(pd.stats.bought_upgrades));
        $('#time_played').html(pretty_int(pd.stats.seconds_played));
        $('#click_sell_amount').html(pretty_int(pd.sell_amount));
        $('#click_make_amount').html(pretty_int(pd.make_amount));
    }

    /****************************************************************************** 
     * SETUP DISPLAY 
     */

    this.setup_display = function() {
        setup_clickers(); 
        setup_sellers();
        setup_upgrades();   
        setup_banks();
        setup_achievements();
    }

    function setup_achievements() { 
       var sortlist = [];
        for(var k in pd.achievements) { 
            sortlist.push([k, pd.achievements[k].group]);
        } 
        var sorted = sortlist.sort(function(x,y) { return x[1] - y[1] });
        var ac_el = $('#achievements');
        ac_el.html('');

        for(var i in sorted) {
            var k = sorted[i][0];
            var ac = pd.achievements[k];
            var template = $('#tpl_achievement').html();
            var data = {'ac':ac, 'id':k};
            //var html = Mustache.to_html(template, data);
            //ac_el.prepend(html);
        }    
    }

    function setup_banks() {
       var sortlist = [];
        for(var k in pd.banks) { 
            sortlist.push([k, pd.banks[k].cost]);
        } 
        var sorted = sortlist.sort(function(x,y) { return x[1] - y[1] });
        var bn_el = $('#banks');
        bn_el.html('');

        for(var i in sorted) {
            var k = sorted[i][0];
            var bn = pd.banks[k];
            var template = $('#tpl_bank').html();
            var data = {'bn':bn, 'id':k};
            //var html = Mustache.to_html(template, data);
           // bn_el.prepend(html);
        }
    }

    function setup_clickers() { 
        var sortlist = [];
        for(var k in pd.clickers) { 
            sortlist.push([k, pd.clickers[k].base_cost]);
        } 
        var sorted = sortlist.sort(function(x,y) { return x[1] - y[1] });

        var cs_el = $('#clickers');
        cs_el.html('');
        
        for(var i in sorted) {
            var k = sorted[i][0];
            var cl = pd.clickers[k];
            var template = $('#tpl_clicker').html();
            var data = {'cl':cl, 'id':k};
            //var html = Mustache.to_html(template, data);
            //cs_el.prepend(html);
        }
    }

    function setup_sellers() { 
        var sortlist = [];
        for(var k in pd.sellers) { 
            sortlist.push([k, pd.sellers[k].base_cost]);
        } 
        var sorted = sortlist.sort(function(x,y) { return x[1] - y[1] });

        var sl_el = $('#sellers');
        sl_el.html('');
        
        for(var i in sorted) {
            var k = sorted[i][0];
            var sl = pd.sellers[k];
            var template = $('#tpl_seller').html();
            var data = {'sl':sl, 'id':k};
            //var html = Mustache.to_html(template, data);
            //sl_el.prepend(html);
        }
    }

    function setup_upgrades() {
        var sortlist = [];
        for(var k in pd.upgrades) { 
            sortlist.push([k, pd.upgrades[k].cost]);
        } 
        var sorted = sortlist.sort(function(x,y) { return x[1] - y[1] });
        var upgs_el = $('#upgrades');
        upgs_el.html('');

        for(var i in sorted) { 
            var k = sorted[i][0];
            var upg = pd.upgrades[k];
            var template = $('#tpl_upgrade').html();
            var data = {'upg':upg, 'id':k};
            //var html = Mustache.to_html(template, data);
            //upgs_el.prepend(html);
        }
    }

    /*******************************************************************************
     * Achievements
     */

    function check_achievements() {
        for(var k in pd.achievements) { 
            var a = pd.achievements[k];
            if(a.unlocked) { 
                continue;
            }
            var pps = a.property.split('.');
            var val = pd;
            for(var i = 0; i<pps.length; i++) { 
                val = val[pps[i]];
            }
            if((val === true)&&(val === a.required)) { 
                unlock_achievement(k);
            }
            else if((val)&&((a.required >= 0 && val >= a.required)||(a.required < 0 && val <= a.required))) {
                unlock_achievement(k);
            } 
        }
    }

    /*******************************************************************************
     * EVENTS 
     */

    this.check_events = function() {
        for(var k in pd.events) { 
            var rnd = Math.random();
            if(pd.events[k].chance > rnd) { 
                run_event(k);
            }
        } 
    }

    function run_event(evk) { 
        if(pd.events[evk]) {
            eval(pd.events[evk].action);
        }
    }

    // Custom Events ---------------------------------------------------------------

    // Meth found, meth per second * r
    function event_found_meth(r) { 
        var amt = pd.stats.clicker_rps * r;
        if(amt < 100) { amt = 100; }
        pd.widgets.amount += amt;
        good_message('You found an extra barrel of meth, with '
            +pretty_bigint(amt)+' batches inside!');
    }

    // Cash found, cash per second * r
    function event_found_cash(r) { 
        var amt = (pd.stats.seller_rps * pd.widget_roi) * r;
        if(amt < 100) { amt = 100; }
        earn_cash(amt);
        if(amt > 10000000000) { 
            good_message('A mystery benefactor has contributed $'
                +pretty_bigint(amt)+' to your cause');
            return;
        }
        if(amt > 10000000) { 
            good_message('You found a truck load of cash, containing $'
                +pretty_bigint(amt)+' inside!');
            return;
        }
        if(amt > 100000) { 
            good_message('You found a briefcase with $'+pretty_int(amt)+' inside!');
            return;
        }
        good_message('You found some extra cash hidden in a shoe box, worth $'
            +pretty_int(amt)+'!');
    }

/*******************************************************************************
 * Messaging 
 */

function add_message(msg, _type) { 
    var el = $("<div></div>");
    el.html(msg);
    el.addClass(_type);
    $('#last_message').html($(el).clone().wrap('<p>').parent().html());
    $('#messages').prepend(el);
    //el.fadeOut(100000);
    if($('#messages div').length > 45) { 
        $('#messages div:last').remove();
    }
}
function error(msg) { 
    add_message('&#10007; '+msg, 'error');    
}
function message(msg) { 
    add_message('&#9993; '+msg, 'message');
}
function good_message(msg) { 
    add_message('&#9733; '+msg, 'good_message');
}
function bad_message(msg) { 
    add_message('&#10007; '+msg, 'bad_message');
}

/*******************************************************************************
 * Tab control
 */
function switch_tab(tbid) {
    var tb_el = $('#'+tbid+'_div');
    $('.tab_div').hide();
    $('.tab').removeClass('active');
    $('#'+tbid+'_tab').addClass('active');
    tb_el.show();
    active_tab = tbid;
    return false;
}

function toggle_tab(tbid) { 
    $('#'+tbid+'_div').toggle(200);
    return false;
}

function pretty_bigint(num) { 
    var sn = '';
    if(num >= 1000000000000000000000000) { 
        return pretty_int(num)
    }    
    if(num >= 1000000000000000000000) { 
        sn = Math.round((num / 1000000000000000000000) * 100) / 100;
        return sn + 'S';
    }
    if(num >= 1000000000000000000) { 
        sn = Math.round((num / 1000000000000000000) * 100) / 100;
        return sn + 'Qt';
    }
    if(num >= 1000000000000000) { 
        sn = Math.round((num / 1000000000000000)*100) / 100;
        return sn + 'Q';
    }
    if(num >= 1000000000000) { 
        sn = Math.round((num / 1000000000000) * 100) / 100;
        return sn + 'T';
    }
    if(num >= 1000000000) { 
        sn = Math.round((num / 1000000000) * 100) / 100;
        return sn + 'B';
    }
    if(num >= 1000000) { 
        sn = Math.round((num / 1000000) * 100) / 100;
        return sn + 'M';
    } 
    return pretty_int(num);
}

function pretty_int(num) {
    if(num < 1000) { 
        num = Math.round(num * 10) / 10;
    } else { 
        num = Math.round(num);
    }
    var num_str = num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ","); 
    return num_str;
}
    
(function (root, factory) {
  if (typeof exports === "object" && exports) {
    factory(exports); // CommonJS
  } else {
    var mustache = {};
    factory(mustache);
    if (typeof define === "function" && define.amd) {
      define(mustache); // AMD
    } else {
      root.Mustache = mustache; // <script>
    }
  }
}(this, function (mustache) {

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var nonSpaceRe = /\S/;
  var eqRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var RegExp_test = RegExp.prototype.test;
  function testRegExp(re, string) {
    return RegExp_test.call(re, string);
  }

  function isWhitespace(string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var Object_toString = Object.prototype.toString;
  var isArray = Array.isArray || function (obj) {
    return Object_toString.call(obj) === '[object Array]';
  };

  function escapeRegExp(string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }

  var entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': '&quot;',
    "'": '&#39;',
    "/": '&#x2F;'
  };

  function escapeHtml(string) {
    return String(string).replace(/[&<>"'\/]/g, function (s) {
      return entityMap[s];
    });
  }

  function Scanner(string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function () {
    return this.tail === "";
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function (re) {
    var match = this.tail.match(re);

    if (match && match.index === 0) {
      this.tail = this.tail.substring(match[0].length);
      this.pos += match[0].length;
      return match[0];
    }

    return "";
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function (re) {
    var match, pos = this.tail.search(re);

    switch (pos) {
    case -1:
      match = this.tail;
      this.pos += this.tail.length;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, pos);
      this.tail = this.tail.substring(pos);
      this.pos += pos;
    }

    return match;
  };

  function Context(view, parent) {
    this.view = view || {};
    this.parent = parent;
    this._cache = {};
  }

  Context.make = function (view) {
    return (view instanceof Context) ? view : new Context(view);
  };

  Context.prototype.push = function (view) {
    return new Context(view, this);
  };

  Context.prototype.lookup = function (name) {
    var value = this._cache[name];

    if (!value) {
      if (name == '.') {
        value = this.view;
      } else {
        var context = this;

        while (context) {
          if (name.indexOf('.') > 0) {
            value = context.view;
            var names = name.split('.'), i = 0;
            while (value && i < names.length) {
              value = value[names[i++]];
            }
          } else {
            value = context.view[name];
          }

          if (value != null) break;

          context = context.parent;
        }
      }

      this._cache[name] = value;
    }

    if (typeof value === 'function') value = value.call(this.view);

    return value;
  };

  function Writer() {
    this.clearCache();
  }

  Writer.prototype.clearCache = function () {
    this._cache = {};
    this._partialCache = {};
  };

  Writer.prototype.compile = function (template, tags) {
    var fn = this._cache[template];

    if (!fn) {
      var tokens = mustache.parse(template, tags);
      fn = this._cache[template] = this.compileTokens(tokens, template);
    }

    return fn;
  };

  Writer.prototype.compilePartial = function (name, template, tags) {
    var fn = this.compile(template, tags);
    this._partialCache[name] = fn;
    return fn;
  };

  Writer.prototype.getPartial = function (name) {
    if (!(name in this._partialCache) && this._loadPartial) {
      this.compilePartial(name, this._loadPartial(name));
    }

    return this._partialCache[name];
  };

  Writer.prototype.compileTokens = function (tokens, template) {
    var self = this;
    return function (view, partials) {
      if (partials) {
        if (typeof partials === 'function') {
          self._loadPartial = partials;
        } else {
          for (var name in partials) {
            self.compilePartial(name, partials[name]);
          }
        }
      }

      return renderTokens(tokens, self, Context.make(view), template);
    };
  };

  Writer.prototype.render = function (template, view, partials) {
    return this.compile(template)(view, partials);
  };

  /**
   * Low-level function that renders the given `tokens` using the given `writer`
   * and `context`. The `template` string is only needed for templates that use
   * higher-order sections to extract the portion of the original template that
   * was contained in that section.
   */
  function renderTokens(tokens, writer, context, template) {
    var buffer = '';

    var token, tokenValue, value;
    for (var i = 0, len = tokens.length; i < len; ++i) {
      token = tokens[i];
      tokenValue = token[1];

      switch (token[0]) {
      case '#':
        value = context.lookup(tokenValue);

        if (typeof value === 'object') {
          if (isArray(value)) {
            for (var j = 0, jlen = value.length; j < jlen; ++j) {
              buffer += renderTokens(token[4], writer, context.push(value[j]), template);
            }
          } else if (value) {
            buffer += renderTokens(token[4], writer, context.push(value), template);
          }
        } else if (typeof value === 'function') {
          var text = template == null ? null : template.slice(token[3], token[5]);
          value = value.call(context.view, text, function (template) {
            return writer.render(template, context);
          });
          if (value != null) buffer += value;
        } else if (value) {
          buffer += renderTokens(token[4], writer, context, template);
        }

        break;
      case '^':
        value = context.lookup(tokenValue);

        // Use JavaScript's definition of falsy. Include empty arrays.
        // See https://github.com/janl/mustache.js/issues/186
        if (!value || (isArray(value) && value.length === 0)) {
          buffer += renderTokens(token[4], writer, context, template);
        }

        break;
      case '>':
        value = writer.getPartial(tokenValue);
        if (typeof value === 'function') buffer += value(context);
        break;
      case '&':
        value = context.lookup(tokenValue);
        if (value != null) buffer += value;
        break;
      case 'name':
        value = context.lookup(tokenValue);
        if (value != null) buffer += mustache.escape(value);
        break;
      case 'text':
        buffer += tokenValue;
        break;
      }
    }

    return buffer;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens(tokens) {
    var tree = [];
    var collector = tree;
    var sections = [];

    var token;
    for (var i = 0, len = tokens.length; i < len; ++i) {
      token = tokens[i];
      switch (token[0]) {
      case '#':
      case '^':
        sections.push(token);
        collector.push(token);
        collector = token[4] = [];
        break;
      case '/':
        var section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : tree;
        break;
      default:
        collector.push(token);
      }
    }

    return tree;
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens(tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, len = tokens.length; i < len; ++i) {
      token = tokens[i];
      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          lastToken = token;
          squashedTokens.push(token);
        }
      }
    }

    return squashedTokens;
  }

  function escapeTags(tags) {
    return [
      new RegExp(escapeRegExp(tags[0]) + "\\s*"),
      new RegExp("\\s*" + escapeRegExp(tags[1]))
    ];
  }

  /**
   * Breaks up the given `template` string into a tree of token objects. If
   * `tags` is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. ["<%", "%>"]). Of
   * course, the default is to use mustaches (i.e. Mustache.tags).
   */
  function parseTemplate(template, tags) {
    template = template || '';
    tags = tags || mustache.tags;

    if (typeof tags === 'string') tags = tags.split(spaceRe);
    if (tags.length !== 2) throw new Error('Invalid tags: ' + tags.join(', '));

    var tagRes = escapeTags(tags);
    var scanner = new Scanner(template);

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace() {
      if (hasTag && !nonSpace) {
        while (spaces.length) {
          delete tokens[spaces.pop()];
        }
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var start, type, value, chr, token;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(tagRes[0]);
      if (value) {
        for (var i = 0, len = value.length; i < len; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push(['text', chr, start, start + 1]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr == '\n') stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(tagRes[0])) break;
      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(eqRe);
        scanner.scan(eqRe);
        scanner.scanUntil(tagRes[1]);
      } else if (type === '{') {
        value = scanner.scanUntil(new RegExp('\\s*' + escapeRegExp('}' + tags[1])));
        scanner.scan(curlyRe);
        scanner.scanUntil(tagRes[1]);
        type = '&';
      } else {
        value = scanner.scanUntil(tagRes[1]);
      }

      // Match the closing tag.
      if (!scanner.scan(tagRes[1])) throw new Error('Unclosed tag at ' + scanner.pos);

      token = [type, value, start, scanner.pos];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        if (sections.length === 0) throw new Error('Unopened section "' + value + '" at ' + start);
        var openSection = sections.pop();
        if (openSection[1] !== value) throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        tags = value.split(spaceRe);
        if (tags.length !== 2) throw new Error('Invalid tags at ' + start + ': ' + tags.join(', '));
        tagRes = escapeTags(tags);
      }
    }

    // Make sure there are no open sections when we're done.
    var openSection = sections.pop();
    if (openSection) throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    tokens = squashTokens(tokens);

    return nestTokens(tokens);
  }

  mustache.name = "mustache.js";
  mustache.version = "0.7.2";
  mustache.tags = ["{{", "}}"];

  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

  mustache.parse = parseTemplate;

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // All Mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates and partials in the default writer.
   */
  mustache.clearCache = function () {
    return defaultWriter.clearCache();
  };

  /**
   * Compiles the given `template` to a reusable function using the default
   * writer.
   */
  mustache.compile = function (template, tags) {
    return defaultWriter.compile(template, tags);
  };

  /**
   * Compiles the partial with the given `name` and `template` to a reusable
   * function using the default writer.
   */
  mustache.compilePartial = function (name, template, tags) {
    return defaultWriter.compilePartial(name, template, tags);
  };

  /**
   * Compiles the given array of tokens (the output of a parse) to a reusable
   * function using the default writer.
   */
  mustache.compileTokens = function (tokens, template) {
    return defaultWriter.compileTokens(tokens, template);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function (template, view, partials) {
    return defaultWriter.render(template, view, partials);
  };

function StringBuffer()
{ 
    this.buffer = []; 
} 

StringBuffer.prototype.append = function append(string)
{ 
    this.buffer.push(string); 
    return this; 
}; 

StringBuffer.prototype.toString = function toString()
{ 
    return this.buffer.join(""); 
}; 

var Base64 =
{
    codex : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

    encode : function (input)
    {
        var output = new StringBuffer();

        var enumerator = new Utf8EncodeEnumerator(input);
        while (enumerator.moveNext())
        {
            var chr1 = enumerator.current;

            enumerator.moveNext();
            var chr2 = enumerator.current;

            enumerator.moveNext();
            var chr3 = enumerator.current;

            var enc1 = chr1 >> 2;
            var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            var enc4 = chr3 & 63;

            if (isNaN(chr2))
            {
                enc3 = enc4 = 64;
            }
            else if (isNaN(chr3))
            {
                enc4 = 64;
            }

            output.append(this.codex.charAt(enc1) + this.codex.charAt(enc2) + this.codex.charAt(enc3) + this.codex.charAt(enc4));
        }

        return output.toString();
    },

    decode : function (input)
    {
        var output = new StringBuffer();

        var enumerator = new Base64DecodeEnumerator(input);
        while (enumerator.moveNext())
        {
            var charCode = enumerator.current;

            if (charCode < 128)
                output.append(String.fromCharCode(charCode));
            else if ((charCode > 191) && (charCode < 224))
            {
                enumerator.moveNext();
                var charCode2 = enumerator.current;

                output.append(String.fromCharCode(((charCode & 31) << 6) | (charCode2 & 63)));
            }
            else
            {
                enumerator.moveNext();
                var charCode2 = enumerator.current;

                enumerator.moveNext();
                var charCode3 = enumerator.current;

                output.append(String.fromCharCode(((charCode & 15) << 12) | ((charCode2 & 63) << 6) | (charCode3 & 63)));
            }
        }

        return output.toString();
    }
}


function Utf8EncodeEnumerator(input)
{
    this._input = input;
    this._index = -1;
    this._buffer = [];
}

Utf8EncodeEnumerator.prototype =
{
    current: Number.NaN,

    moveNext: function()
    {
        if (this._buffer.length > 0)
        {
            this.current = this._buffer.shift();
            return true;
        }
        else if (this._index >= (this._input.length - 1))
        {
            this.current = Number.NaN;
            return false;
        }
        else
        {
            var charCode = this._input.charCodeAt(++this._index);

            // "\r\n" -> "\n"
            //
            if ((charCode == 13) && (this._input.charCodeAt(this._index + 1) == 10))
            {
                charCode = 10;
                this._index += 2;
            }

            if (charCode < 128)
            {
                this.current = charCode;
            }
            else if ((charCode > 127) && (charCode < 2048))
            {
                this.current = (charCode >> 6) | 192;
                this._buffer.push((charCode & 63) | 128);
            }
            else
            {
                this.current = (charCode >> 12) | 224;
                this._buffer.push(((charCode >> 6) & 63) | 128);
                this._buffer.push((charCode & 63) | 128);
            }

            return true;
        }
    }
}

function Base64DecodeEnumerator(input)
{
    this._input = input;
    this._index = -1;
    this._buffer = [];
}
        
</script>

<div id="left_wrap" class="left_width">
    <div id="make_sell_spacer"></div>  
    <div id="left_floatable">     
    <div id="make_sell_wrap">
    <div id="make_div">
        <p>
            <span id="make_lbl">widgets</span>
            (purity is <em><span id="make_qlt">NA</span></em>)<br />
            <strong><span id="make_amt">0</span></strong><br />
            <small><span id="clicker_rps">0</span> per second (net)</small><br />
            <small><span id="clicker_rps_g">0</span> per second (gross)</small>
        </p>
        <div id="make_btn">make</div>
    </div>

    <div id="sell_div">
        <p>
            <span id="sell_lbl">cash</span>
            ($<span id="sell_roi">0</span> ea)<br />
            $<strong><span id="sell_amt">0</span></strong><br />
            <small>$<span id="safe_cash">0</span> laundered</small><br />
            <small>$<span id="seller_rps">0</span> per second</small>
        </p>
        <div id="sell_btn">sell</div>
    </div>
    <div class="clear"></div>
    </div>

    <div id="make_sell_pad"></div>

    </div> <!-- End left floatable -->
</div> <!-- End left_wrap -->

<div id="tab_btns" class="tabs">
    <button onclick="switch_tab('clickers');" id="clickers_tab" class="tab">
        Manufacturing (<span id="clickers_unlocked">0</span>/<span id="clickers_total">0</span>)
    </button>
    <button onclick="switch_tab('sellers');" id="sellers_tab" class="tab">
        Distribution (<span id="sellers_unlocked">0</span>/<span id="sellers_total">0</span>)
    </button>
    <button onclick="switch_tab('upgrades');" id="upgrades_tab" class="tab">
        Upgrades (<span id="upgrades_unlocked">0</span>/<span id="upgrades_total">0</span>)
    </button>
    <button onclick="switch_tab('misc');" id="misc_tab" class="tab">
        Options &amp; Stats
    </button>
</div>

<div id="tab_divs">

    <div class="tab_div" id="clickers_div" style="display:none;">
        <div id="clickers"></div>
    </div>

    <div class="tab_div" id="sellers_div" style="display:none;">
        <div id="sellers"></div>
    </div>

    <div class="tab_div" id="upgrades_div" style="display:none;">
        <div id="upgrades"></div>
    </div>

    <div class="tab_div" id="banks_div" style="display:none;">
        <div class="w_div">
            <h3>
                <a href="#" onclick="$('#toggle_finance_info').toggle(100); return false;">
                Laundering 
                </a>
                <small class="pull_right">$<span id="bank_rps">0</span>/sec</small>
            </h3>
            <div id="toggle_finance_info">
            <p class="small">Total laundered <b>$<span id="bank_total">0</span></b>
                <br /><br />
                Laundered cash is the amount of <em>your total cash</em> that is 
                safe from being stolen or
                seized by the DEA or IRS. The more laundered to 
                total cash you have, the lower the likelihood that 
                you'll be audited. Laundered cash is not a separate resource,
                so it can never be higher than your total cash.
                
                </p>
            </div>
        </div>
        <div id="banks"></div>
    </div>

    <div class="tab_div w_div" id="misc_div" style="display:none;">
        <div class="pull_left space_left">
            <h3>Instructions</h3>
            <ol>
                <li>Cook batches of meth</li>
                <li>Sell meth</li>
                <li>Buy stuff with your drug money</li>
            </ol>
        </div>

        <div class="clear"></div>
    </div>
</div>

<div class="make_up"></div>
<div class="sell_up"></div>
    
</body>
</html>
